{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/lib/client.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n    AlreadyConnectedError,\r\n    AlreadyConnectingError,\r\n    FetchIsLiveError,\r\n    InvalidResponseError,\r\n    UserOfflineError\r\n} from '@/types/errors';\r\n\r\nimport TypedEventEmitter from 'typed-emitter';\r\nimport { EventEmitter } from 'node:events';\r\nimport TikTokWsClient from '@/lib/ws/lib/ws-client';\r\nimport Config from '@/lib/config';\r\nimport { DecodedData, RoomGiftInfo, RoomInfo, TikTokLiveConnectionOptions, WebSocketParams } from '@/types/client';\r\nimport { validateAndNormalizeUniqueId } from '@/lib/utilities';\r\nimport { RoomInfoResponse, TikTokWebClient } from '@/lib/web';\r\nimport { EulerSigner } from '@/lib/web/lib/tiktok-signer';\r\nimport {\r\n    ClientEventMap,\r\n    ConnectState,\r\n    ControlEvent,\r\n    TikTokLiveConnectionState,\r\n    WebcastEvent,\r\n    WebcastEventMap\r\n} from '@/types/events';\r\nimport { IWebcastRoomChatPayload, IWebcastRoomChatRouteResponse } from '@eulerstream/euler-api-sdk';\r\nimport { ControlAction, ProtoMessageFetchResult } from '@/types';\r\n\r\n\r\nexport class TikTokLiveConnection extends (EventEmitter as new () => TypedEventEmitter<ClientEventMap>) {\r\n\r\n    // Public properties\r\n    public webClient: TikTokWebClient;\r\n    public wsClient: TikTokWsClient | null = null;\r\n\r\n    // Protected properties\r\n    protected _roomInfo: RoomInfo | null = null;\r\n    protected _availableGifts: Record<any, any> | null = null;\r\n    protected _connectState: ConnectState = ConnectState.DISCONNECTED;\r\n    public readonly options: TikTokLiveConnectionOptions;\r\n\r\n    /**\r\n     * Create a new TikTokLiveConnection instance\r\n     * @param {string} uniqueId TikTok username (from URL)\r\n     * @param {object} [options] Connection options\r\n     * @param {boolean} [options[].authenticateWs=false] Authenticate the WebSocket connection using the session ID from the \"sessionid\" cookie\r\n     * @param {boolean} [options[].processInitialData=true] Process the initital data which includes messages of the last minutes\r\n     * @param {boolean} [options[].fetchRoomInfoOnConnect=false] Fetch the room info (room status, streamer info, etc.) on connect (will be returned when calling connect())\r\n     * @param {boolean} [options[].enableExtendedGiftInfo=false] Enable this option to get extended information on 'gift' events like gift name and cost\r\n     * @param {boolean} [options[].enableRequestPolling=true] Use request polling if no WebSocket upgrade is offered. If `false` an exception will be thrown if TikTok does not offer a WebSocket upgrade.\r\n     * @param {number} [options[].requestPollingIntervalMs=1000] Request polling interval if WebSocket is not used\r\n     * @param {string} [options[].sessionId=null] The session ID from the \"sessionid\" cookie is required if you want to send automated messages in the chat.\r\n     * @param {object} [options[].webClientParams={}] Custom client params for Webcast API\r\n     * @param {object} [options[].webClientHeaders={}] Custom request headers for axios\r\n     * @param {object} [options[].websocketHeaders={}] Custom request headers for websocket.client\r\n     * @param {object} [options[].webClientOptions={}] Custom request options for axios. Here you can specify an `httpsAgent` to use a proxy and a `timeout` value for example.\r\n     * @param {object} [options[].websocketOptions={}] Custom request options for websocket.client. Here you can specify an `agent` to use a proxy and a `timeout` value for example.\r\n     * @param {string[]} [options[].preferredAgentIds=[]] Preferred agent IDs to use for the WebSocket connection. If not specified, the default agent IDs will be used.\r\n     * @param {boolean} [options[].connectWithUniqueId=false] Connect to the live stream using the unique ID instead of the room ID. If `true`, the room ID will be fetched from the TikTok API.\r\n     * @param {boolean} [options[].logFetchFallbackErrors=false] Log errors when falling back to the API or Euler source\r\n     * @param {function} [options[].signedWebSocketProvider] Custom function to fetch the signed WebSocket URL. If not specified, the default function will be used.\r\n     * @param {EulerSigner} [signer] TikTok Signer instance. If not provided, a new instance will be created using the provided options\r\n     */\r\n    constructor(\r\n        public readonly uniqueId: string,\r\n        options?: Partial<TikTokLiveConnectionOptions>,\r\n        public readonly signer?: EulerSigner\r\n    ) {\r\n        super();\r\n        this.uniqueId = validateAndNormalizeUniqueId(uniqueId);\r\n\r\n        // Assign the options\r\n        this.options = {\r\n            preferredAgentIds: [],\r\n            connectWithUniqueId: false,\r\n            processInitialData: true,\r\n            fetchRoomInfoOnConnect: true,\r\n            enableExtendedGiftInfo: false,\r\n            enableRequestPolling: true,\r\n            requestPollingIntervalMs: 1000,\r\n            sessionId: null,\r\n            ttTargetIdc: null,\r\n            signApiKey: null,\r\n            disableEulerFallbacks: false,\r\n\r\n            // Override Http client params\r\n            webClientParams: {},\r\n            webClientHeaders: {},\r\n            webClientOptions: {},\r\n\r\n            // Override WebSocket params\r\n            wsClientHeaders: {},\r\n            wsClientOptions: {},\r\n            wsClientParams: {},\r\n\r\n            authenticateWs: false,\r\n            signedWebSocketProvider: undefined,\r\n            ...options\r\n        };\r\n\r\n        this.webClient = new TikTokWebClient(\r\n            {\r\n                customHeaders: this.options?.webClientHeaders || {},\r\n                axiosOptions: this.options?.webClientOptions,\r\n                clientParams: this.options?.webClientParams || {},\r\n                authenticateWs: this.options?.authenticateWs || false,\r\n                signApiKey: this.options?.signApiKey ?? undefined\r\n            },\r\n            signer\r\n        );\r\n\r\n        this.webClient.cookieJar.setSession(this.options.sessionId, this.options.ttTargetIdc);\r\n        this.setDisconnected();\r\n    }\r\n\r\n    /**\r\n     * Set the connection state to disconnected\r\n     * @protected\r\n     */\r\n    protected setDisconnected() {\r\n        this._connectState = ConnectState.DISCONNECTED;\r\n        this._roomInfo = null;\r\n\r\n        // Reset the client parameters\r\n        this.clientParams.cursor = '';\r\n        this.clientParams.room_id = '';\r\n        this.clientParams.internal_ext = '';\r\n    }\r\n\r\n    /**\r\n     * Get the current Room Info\r\n     */\r\n    public get roomInfo(): RoomInfoResponse {\r\n        return this._roomInfo;\r\n    }\r\n\r\n    /**\r\n     * Get the available gifts\r\n     */\r\n    public get availableGifts() {\r\n        return this._availableGifts;\r\n    }\r\n\r\n    /**\r\n     * Get the current connection state\r\n     */\r\n    public get isConnecting() {\r\n        return this._connectState === ConnectState.CONNECTING;\r\n    }\r\n\r\n    /**\r\n     * Check if the connection is established\r\n     */\r\n    public get isConnected() {\r\n        return this._connectState === ConnectState.CONNECTED;\r\n    }\r\n\r\n    /**\r\n     * Get the current client parameters\r\n     */\r\n    public get clientParams() {\r\n        return this.webClient.clientParams;\r\n    }\r\n\r\n    /**\r\n     * Get the current room ID\r\n     */\r\n    public get roomId(): string {\r\n        return this.webClient.roomId;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the current connection state including the cached room info and all available gifts\r\n     * (if `enableExtendedGiftInfo` option enabled)\r\n     */\r\n    public get state(): TikTokLiveConnectionState {\r\n        return {\r\n            isConnected: this.isConnected,\r\n            roomId: this.roomId,\r\n            roomInfo: this.roomInfo,\r\n            availableGifts: this.availableGifts\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Connects to the live stream of the specified streamer\r\n     * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API\r\n     * @returns The current connection state\r\n     */\r\n    async connect(roomId?: string): Promise<TikTokLiveConnectionState> {\r\n\r\n        switch (this._connectState) {\r\n            case ConnectState.CONNECTED:\r\n                throw new AlreadyConnectedError('Already connected!');\r\n\r\n            case ConnectState.CONNECTING:\r\n                throw new AlreadyConnectingError('Already connecting!');\r\n\r\n            default:\r\n            case ConnectState.DISCONNECTED:\r\n                try {\r\n                    this._connectState = ConnectState.CONNECTING;\r\n                    await this._connect(roomId);\r\n                    this._connectState = ConnectState.CONNECTED;\r\n                    this.emit(ControlEvent.CONNECTED, this.state);\r\n                    return this.state;\r\n                } catch (err) {\r\n                    this._connectState = ConnectState.DISCONNECTED;\r\n                    this.handleError(err, 'Error while connecting');\r\n                    throw err;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connects to the live stream of the specified streamer\r\n     *\r\n     * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API\r\n     * @protected\r\n     */\r\n    protected async _connect(roomId?: string): Promise<void> {\r\n\r\n        // First we set the Room ID\r\n        if (!this.options.connectWithUniqueId || this.options.fetchRoomInfoOnConnect || this.options.enableExtendedGiftInfo) {\r\n            this.clientParams.room_id = roomId || this.clientParams.room_id || await this.fetchRoomId();\r\n        }\r\n\r\n        // <Optional> Fetch Room Info\r\n        if (this.options?.fetchRoomInfoOnConnect) {\r\n            this._roomInfo = await this.fetchRoomInfo();\r\n            if (this._roomInfo.data.status === 4) {\r\n                throw new UserOfflineError('The requested user isn\\'t online :(');\r\n            }\r\n        }\r\n\r\n        // <Optional> Fetch Gift Info\r\n        if (this.options?.enableExtendedGiftInfo) {\r\n            this._availableGifts = await this.fetchAvailableGifts();\r\n        }\r\n\r\n        // <Required> Fetch initial room info. Let the user specify their own backend for signing, if they don't want to use Euler\r\n        const protoMessageFetchResult: ProtoMessageFetchResult = await (this.options.signedWebSocketProvider || this.webClient.fetchSignedWebSocketFromEuler)(\r\n            {\r\n                roomId: (roomId || !this.options.connectWithUniqueId) ? this.roomId : undefined,\r\n                uniqueId: this.options.connectWithUniqueId ? this.uniqueId : undefined,\r\n                preferredAgentIds: this.options.preferredAgentIds,\r\n                sessionId: this.options.authenticateWs ? this.options.sessionId : undefined\r\n            }\r\n        );\r\n\r\n        // <Optional> Process the initial data\r\n        if (this.options?.processInitialData) {\r\n            await this.processProtoMessageFetchResult(protoMessageFetchResult);\r\n        }\r\n\r\n        // If we didn't receive a cursor\r\n        if (!protoMessageFetchResult.cursor) {\r\n            throw new InvalidResponseError('Missing cursor in initial fetch response.');\r\n        }\r\n\r\n        // Update client parameters\r\n        this.clientParams.cursor = protoMessageFetchResult.cursor;\r\n        this.clientParams.internal_ext = protoMessageFetchResult.internalExt;\r\n\r\n        // Connect to the WebSocket\r\n        const wsParams: WebSocketParams = {\r\n            compress: 'gzip',\r\n            room_id: this.roomId,\r\n            internal_ext: protoMessageFetchResult.internalExt,\r\n            cursor: protoMessageFetchResult.cursor,\r\n            ...protoMessageFetchResult.wsParams\r\n        };\r\n\r\n        this.wsClient = await this.setupWebsocket(protoMessageFetchResult.wsUrl, wsParams);\r\n        this.emit(ControlEvent.WEBSOCKET_CONNECTED, this.wsClient);\r\n\r\n    }\r\n\r\n    /**\r\n     * Disconnects the connection to the live stream\r\n     */\r\n    async disconnect(): Promise<void> {\r\n        if (this.isConnected) {\r\n            await this.wsClient?.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the room ID from the TikTok API\r\n     * @param uniqueId Optional unique ID to use instead of the current one\r\n     */\r\n    public async fetchRoomId(uniqueId?: string): Promise<string> {\r\n        let errors: any[] = [];\r\n        uniqueId ||= this.uniqueId;\r\n\r\n        // Method 1\r\n        try {\r\n            const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId: uniqueId });\r\n            const roomId = roomInfo.liveRoomUserInfo.liveRoom.roomId;\r\n            if (!roomId) throw new Error('Failed to extract Room ID from HTML.');\r\n            return roomId;\r\n        } catch (ex) {\r\n            this.handleError(ex, 'Failed to retrieve Room ID from main page, falling back to API source...');\r\n            errors.push(ex);\r\n        }\r\n\r\n        // Method 2 (API Fallback)\r\n        try {\r\n            const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId: uniqueId });\r\n            const roomId = roomData?.data?.user?.roomId;\r\n            if (!roomId) throw new Error('Failed to extract Room ID from API.');\r\n            return roomId;\r\n        } catch (ex) {\r\n            this.handleError(ex, 'Failed to retrieve Room ID from API source, falling back to Euler source...');\r\n            errors.push(ex);\r\n        }\r\n\r\n        // Method 3 (Euler Fallback)\r\n        if (!this.options.disableEulerFallbacks) {\r\n            try {\r\n                const response = await this.webClient.fetchRoomIdFromEuler({ uniqueId: uniqueId });\r\n                if (!response.ok) throw new Error(`Failed to retrieve Room ID from Euler due to an error: ${response.message}`);\r\n                if (!response.room_id) throw new Error('Failed to extract Room ID from Euler.');\r\n                return response.room_id;\r\n            } catch (err) {\r\n                this.handleError(err, 'Failed to retrieve Room ID from Euler source, no more sources available...');\r\n                errors.push(err);\r\n            }\r\n        }\r\n\r\n        // If we reach this point, it means all sources have failed\r\n        const errMsg: string = 'Failed to retrieve Room ID from all sources.';\r\n        const failErr = new FetchIsLiveError(errors, errMsg);\r\n        this.handleError(failErr, errMsg);\r\n        throw failErr;\r\n    }\r\n\r\n    public async fetchIsLive(): Promise<boolean> {\r\n        const errors: any[] = [];\r\n        const isOnline = (status: number) => status !== 4;\r\n\r\n        // Method 1 (HTML)\r\n        try {\r\n            const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId: this.uniqueId });\r\n            if (roomInfo?.liveRoomUserInfo?.liveRoom?.status === undefined) throw new Error('Failed to extract status from HTML.');\r\n            return isOnline(roomInfo?.liveRoomUserInfo?.liveRoom?.status);\r\n        } catch (ex) {\r\n            this.handleError(ex, 'Failed to retrieve room info for live status from main page, falling back to API source...');\r\n            errors.push(ex);\r\n        }\r\n\r\n        // Method 2 (API)\r\n        try {\r\n            const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId: this.uniqueId });\r\n            if (roomData?.data?.liveRoom?.status === undefined) throw new Error('Failed to extract status from API.');\r\n            return isOnline(roomData?.data?.liveRoom?.status);\r\n        } catch (err) {\r\n            this.handleError(err, 'Failed to retrieve room info for live status from API source, falling back to Euler source...');\r\n            errors.push(err);\r\n        }\r\n\r\n        // Method 3 (Euler)\r\n        if (!this.options.disableEulerFallbacks) {\r\n            try {\r\n                const roomData = await this.webClient.fetchRoomIdFromEuler({ uniqueId: this.uniqueId });\r\n                if (roomData.code !== 200) throw new Error('Failed to extract status from Euler.');\r\n                return roomData.is_live;\r\n            } catch (err) {\r\n                this.handleError(err, 'Failed to retrieve room info for live status from Euler source, no more sources available...');\r\n                errors.push(err);\r\n            }\r\n        }\r\n\r\n        // If we reach this point, it means all sources have failed\r\n        const errMsg: string = 'Failed to retrieve live status rom all sources.';\r\n        const failErr = new FetchIsLiveError(errors, errMsg);\r\n        this.handleError(failErr, errMsg);\r\n        throw failErr;\r\n\r\n    }\r\n\r\n    /**\r\n     * Wait until the streamer is live\r\n     * @param seconds Number of seconds to wait before checking if the streamer is live again\r\n     */\r\n    public async waitUntilLive(seconds: number = 60): Promise<void> {\r\n        seconds = Math.max(30, seconds);\r\n\r\n        return new Promise(async (resolve) => {\r\n            const fetchIsLive = async () => {\r\n                const isLive = await this.fetchIsLive();\r\n\r\n                if (isLive) {\r\n                    clearInterval(interval);\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            const interval = setInterval(async () => fetchIsLive(), seconds * 1000);\r\n            await fetchIsLive();\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Get the current room info (including streamer info, room status and statistics)\r\n     * @returns Promise that will be resolved when the room info has been retrieved from the API\r\n     */\r\n    public async fetchRoomInfo(): Promise<RoomInfoResponse> {\r\n        if (!this.webClient.roomId) await this.fetchRoomId();\r\n        this._roomInfo = await this.webClient.fetchRoomInfo();\r\n        return this._roomInfo;\r\n    }\r\n\r\n    /**\r\n     * Get the available gifts in the current room\r\n     * @returns Promise that will be resolved when the available gifts have been retrieved from the API\r\n     */\r\n    public async fetchAvailableGifts(): Promise<RoomGiftInfo> {\r\n        try {\r\n            let response = await this.webClient.getJsonObjectFromWebcastApi('gift/list/', this.clientParams);\r\n            return response.data.gifts;\r\n        } catch (err) {\r\n            throw new InvalidResponseError(`Failed to fetch available gifts. ${err.message}`, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a message to a TikTok LIVE Room\r\n     *\r\n     * @param content Message content to send to the stream\r\n     * @param options Optional parameters for the message (incl. parameter overrides)\r\n     */\r\n    public async sendMessage(content: string, options?: Partial<Omit<IWebcastRoomChatPayload, 'content'>>): Promise<IWebcastRoomChatRouteResponse> {\r\n\r\n        const roomId = options?.roomId || this.roomId;\r\n        if (!roomId) {\r\n            throw new Error('Room ID is required to send a message.');\r\n        }\r\n\r\n        const sessionId = options?.sessionId || this.webClient.cookieJar.sessionId;\r\n        if (!sessionId) {\r\n            throw new Error('Session ID is required to send a message.');\r\n        }\r\n\r\n        const ttTargetIdc = options?.ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;\r\n        if (!ttTargetIdc) {\r\n            throw new Error('ttTargetIdc is required to send a message.');\r\n        }\r\n\r\n        return this.webClient.sendRoomChatFromEuler(\r\n            {\r\n                content: content,\r\n                roomId: roomId,\r\n                sessionId: sessionId,\r\n                ttTargetIdc: ttTargetIdc\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Set up the WebSocket connection\r\n     *\r\n     * @param wsUrl WebSocket URL\r\n     * @param wsParams WebSocket parameters\r\n     * @returns Promise that will be resolved when the WebSocket connection is established\r\n     * @protected\r\n     */\r\n    protected async setupWebsocket(wsUrl: string, wsParams: WebSocketParams): Promise<TikTokWsClient> {\r\n        return new Promise<TikTokWsClient>((resolve, reject) => {\r\n\r\n            // Instantiate the client\r\n            const wsClient = new TikTokWsClient(\r\n                wsUrl,\r\n                this.webClient.cookieJar,\r\n                { ...Config.DEFAULT_WS_CLIENT_PARAMS, ...this.options.wsClientParams, ...wsParams },\r\n                { ...Config.DEFAULT_WS_CLIENT_HEADERS, ...this.options?.wsClientHeaders },\r\n                this.options?.wsClientOptions\r\n            );\r\n\r\n            // Handle the connection\r\n            wsClient.on('connect', (ws) => {\r\n                clearTimeout(connectTimeout);\r\n                ws.on('error', (e: any) => this.handleError(e, 'WebSocket Error'));\r\n                ws.on('close', () => {\r\n                    this.setDisconnected();\r\n                    this.emit(ControlEvent.DISCONNECTED);\r\n                });\r\n                resolve(wsClient);\r\n            });\r\n\r\n            wsClient.on('connectFailed', (err: any) => reject(`Websocket connection failed, ${err}`));\r\n            wsClient.on('protoMessageFetchResult', this.processProtoMessageFetchResult.bind(this));\r\n            wsClient.on('webSocketData', (data: Uint8Array) => this.emit(ControlEvent.WEBSOCKET_DATA, data));\r\n            wsClient.on('messageDecodingFailed', (err: any) => this.handleError(err, 'Websocket message decoding failed'));\r\n            const connectTimeout = setTimeout(() => reject('Websocket not responding'), 20_000);\r\n        });\r\n    }\r\n\r\n    protected async processProtoMessageFetchResult(protoMessageFetchResult: ProtoMessageFetchResult): Promise<void> {\r\n\r\n        for (const message of protoMessageFetchResult.messages) {\r\n\r\n            if (!message.decodedData) {\r\n                continue;\r\n            }\r\n\r\n            // Emit the decoded data\r\n            this.emit(\r\n                ControlEvent.DECODED_DATA,\r\n                message.type,\r\n                message.decodedData,\r\n                message.payload\r\n            );\r\n\r\n            // Process & emit decoded data depending on the message type\r\n            try {\r\n                await this.processDecodedData(message.decodedData);\r\n            } catch (ex) {\r\n                this.handleError(ex, 'Failed to process decoded data');\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    protected async processDecodedData({ data, type }: DecodedData): Promise<boolean | void> {\r\n\r\n        // Emit a decoded data event\r\n        switch (type) {\r\n\r\n            case 'WebcastSocialMessage':\r\n\r\n                if (data.common.displayText.displayType?.includes('follow')) {\r\n                    return this.emit(WebcastEvent.FOLLOW, data);\r\n                }\r\n\r\n                if (data.common.displayText.displayType?.includes('share')) {\r\n                    return this.emit(WebcastEvent.SHARE, data);\r\n                }\r\n\r\n                // First, emit the raw social message\r\n                return this.emit(WebcastEvent.SOCIAL, data);\r\n\r\n            case 'WebcastControlMessage':\r\n\r\n                // Send raw message\r\n                this.emit(WebcastEvent.CONTROL_MESSAGE, data);\r\n\r\n                if (data.action === ControlAction.CONTROL_ACTION_STREAM_ENDED || data.action === ControlAction.CONTROL_ACTION_STREAM_SUSPENDED) {\r\n                    this.emit(WebcastEvent.STREAM_END, { action: data.action });\r\n                    await this.disconnect();\r\n                }\r\n\r\n                return;\r\n\r\n            case 'WebcastGiftMessage':\r\n\r\n                // Add extended gift info if available\r\n                if (Array.isArray(this.availableGifts) && data.giftId) {\r\n                    data.extendedGiftInfo = this.availableGifts.find((x) => x.id === data.giftId);\r\n                }\r\n\r\n                return this.emit(WebcastEvent.GIFT, data);\r\n            default:\r\n\r\n                // Handle all other events\r\n                const basicEvent = WebcastEventMap[type];\r\n                return basicEvent && this.emit(basicEvent, data);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Handle the error event\r\n     *\r\n     * @param exception Exception object\r\n     * @param info Additional information about the error\r\n     * @protected\r\n     */\r\n    protected handleError(exception: Error, info: string): void {\r\n        if (this.listenerCount(ControlEvent.ERROR) < 1) {\r\n            return;\r\n        }\r\n\r\n        this.emit(ControlEvent.ERROR, { info, exception });\r\n    }\r\n\r\n}\r\n\r\n\r\n"]}