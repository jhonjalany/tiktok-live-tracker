{"version":3,"file":"fetch-signed-websocket-euler.js","sourceRoot":"","sources":["../../../../src/lib/web/routes/fetch-signed-websocket-euler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Route } from '@/types/route';\r\nimport { AxiosResponse } from 'axios';\r\nimport {\r\n    AuthenticatedWebSocketConnectionError,\r\n    ErrorReason,\r\n    FetchSignedWebSocketIdentityParameterError,\r\n    PremiumFeatureError,\r\n    SignAPIError,\r\n    SignatureRateLimitError\r\n} from '@/types/errors';\r\nimport Config from '@/lib/config';\r\nimport { deserializeMessage } from '@/lib';\r\nimport { FetchSignedWebSocketParams } from '@/types/client';\r\nimport { ProtoMessageFetchResult } from '@/types';\r\n\r\n\r\nexport type FetchSignedWebSocketFromEulerRouteParams = FetchSignedWebSocketParams;\r\n\r\nexport class FetchSignedWebSocketFromEulerRoute extends Route<FetchSignedWebSocketFromEulerRouteParams, ProtoMessageFetchResult> {\r\n\r\n    async call(\r\n        {\r\n            roomId,\r\n            uniqueId,\r\n            preferredAgentIds,\r\n            sessionId,\r\n            ttTargetIdc\r\n        }: FetchSignedWebSocketFromEulerRouteParams\r\n    ): Promise<ProtoMessageFetchResult> {\r\n\r\n        if (!roomId && !uniqueId) {\r\n            throw new FetchSignedWebSocketIdentityParameterError(\r\n                'Either roomId or uniqueId must be provided.'\r\n            );\r\n        }\r\n\r\n        if (roomId && uniqueId) {\r\n            throw new FetchSignedWebSocketIdentityParameterError(\r\n                'Both roomId and uniqueId cannot be provided at the same time.'\r\n            );\r\n        }\r\n\r\n        const preferredAgentIdsParam = preferredAgentIds?.join(',') ?? null;\r\n        const resolvedSessionId = sessionId || this.webClient.cookieJar.sessionId;\r\n        const resolvedTtTargetIdc = ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;\r\n\r\n        if (resolvedSessionId && !resolvedTtTargetIdc) {\r\n            throw new FetchSignedWebSocketIdentityParameterError(\r\n                'ttTargetIdc must be set when sessionId is provided.'\r\n            );\r\n        }\r\n\r\n        if (this.webClient.configuration.authenticateWs && resolvedSessionId) {\r\n            const envHost = process.env.WHITELIST_AUTHENTICATED_SESSION_ID_HOST;\r\n            const expectedHost = new URL(this.webClient.webSigner.configuration.basePath).host;\r\n\r\n            if (!envHost) {\r\n                throw new AuthenticatedWebSocketConnectionError(\r\n                    `authenticate_websocket is true, but no whitelist host defined. Set the env var WHITELIST_AUTHENTICATED_SESSION_ID_HOST to proceed.`\r\n                );\r\n            }\r\n\r\n            if (envHost !== expectedHost) {\r\n                throw new AuthenticatedWebSocketConnectionError(\r\n                    `The env var WHITELIST_AUTHENTICATED_SESSION_ID_HOST \"${envHost}\" does not match sign server host \"${expectedHost}\".`\r\n                );\r\n            }\r\n\r\n        }\r\n\r\n        let response: AxiosResponse<ArrayBuffer>;\r\n\r\n        try {\r\n            response = await this.webClient.webSigner.webcast.fetchWebcastURL(\r\n                'ttlive-node',\r\n                roomId,\r\n                uniqueId,\r\n                this.webClient.clientParams?.cursor ?? undefined,\r\n                resolvedSessionId,\r\n                Config.DEFAULT_HTTP_CLIENT_HEADERS['User-Agent'],\r\n                preferredAgentIdsParam,\r\n                resolvedTtTargetIdc,\r\n                { responseType: 'arraybuffer' }\r\n            ) as any;\r\n        } catch (err: any) {\r\n            throw new SignAPIError(ErrorReason.CONNECT_ERROR, undefined, undefined, 'Failed to connect to sign server.', null, err);\r\n        }\r\n\r\n        if (response.status === 429) {\r\n            // Convert arraybuffer to JSON\r\n            const data = JSON.parse(Buffer.from(response.data).toString('utf-8')) as any;\r\n            const message = process.env.SIGN_SERVER_MESSAGE_DISABLED ? null : data?.message;\r\n            const label = data?.limit_label ? `(${data.limit_label}) ` : '';\r\n            throw new SignatureRateLimitError(message, `${label}Too many connections started, try again later.`, response);\r\n        }\r\n\r\n        if (response.status === 402) {\r\n            // Convert arraybuffer to JSON\r\n            const data = JSON.parse(Buffer.from(response.data).toString('utf-8')) as any;\r\n            const message = process.env.SIGN_SERVER_MESSAGE_DISABLED ? null : data?.message;\r\n            throw new PremiumFeatureError(message, 'Error fetching the signed TikTok WebSocket');\r\n        }\r\n\r\n        const logId: number | undefined = response.headers['X-Log-Id'] && parseInt(response.headers['X-Log-Id']);\r\n        const agentId: string | undefined = response.headers['X-Agent-ID'];\r\n\r\n        if (response.status !== 200) {\r\n            let payload: string;\r\n            try {\r\n                payload = Buffer.from(response.data).toString('utf-8');\r\n            } catch {\r\n                payload = `\"${response.statusText}\"`;\r\n            }\r\n\r\n            throw new SignAPIError(\r\n                ErrorReason.SIGN_NOT_200,\r\n                logId,\r\n                agentId,\r\n                `Unexpected sign server status ${response.status}. Payload:\\n${payload}`\r\n            );\r\n        }\r\n\r\n        if (!response.headers['x-set-tt-cookie']) {\r\n            throw new SignAPIError(\r\n                ErrorReason.EMPTY_COOKIES,\r\n                logId,\r\n                agentId,\r\n                'No cookies received from sign server.'\r\n            );\r\n        }\r\n\r\n        this.webClient.cookieJar.processSetCookieHeader(response.headers['x-set-tt-cookie'] || '');\r\n        this.webClient.roomId = response.headers['x-room-id'] || this.webClient.roomId;\r\n        return deserializeMessage('ProtoMessageFetchResult', Buffer.from(response.data));\r\n    }\r\n\r\n}\r\n"]}